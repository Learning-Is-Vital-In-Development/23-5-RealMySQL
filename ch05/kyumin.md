# CH 05. 트랜잭션과 잠금

---

트랜잭션은 작업의 완정성을 보장해 주는 것이다. 그리고 잠금은 동시성을 제어하기 위한 기능이다.

## 5.1 트랜잭션

---

이번장에서는 트랜잭션을 지원하는 MyISAM, 트랜잭션을 지원하는 InnoDB의 처리 방식 차이를 살펴본다.

### 5.1.1 MySQL에서의 트랜잭션

---

트랜잭션은 논리적인 작업 셋이 100% 적용되거나 아무것도 적용되지 않아야함을 보장해 준다.
간단한 예로 트랜잭션 관점에서 InnoDB와 MyISAM 테이블의 차이를 살펴보자.

~~~mysql
mysql> insert into tab_myisam (fdpk) values(3);
mysql> insert into tab_innodb(fdpk)values(3);

mysql> set autocommit = on;

mysql> insert into tab_myisam (fdpk) values (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'tab_myisam.PRIMARY'
mysql> insert into tab_innodb (fdpk) values (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'tab_innodb.PRIMARY'
mysql> select * from tab_myisam;
+------+
| fdpk |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)

mysql> select * from tab_innodb;
+------+
| fdpk |
+------+
|    3 |
+------+
1 row in set (0.01 sec)
~~~

MyISAM은 트랜잭션을 지원하지 않기 때문에 쿼리문에서 (1),(2)을 순차 실행하여 적용을하고 (3)을 적용하는 과정에서 키 중복 오류가 발생하고 난 후에
쿼리가 종료되어 (1),(2)는 그대로 남게 된다. Memory 스토리지 엔진에서도 똑같이 동작한다.

하지만 InnoDB의 경우 트랜잭션을 지원하기 때문에 (3)을 저장하는 과정에서 오류가 발생하였기에 쿼리문 전체에 대하여 롤백이 진행되었다. 따라서 (1),(2) 데이터들은 저장되지 않았다.

MyISAM에서 발생하는 문제를 부분 업데이트(Partial Update)라고 표현하며, 이러한 문제는 데이터 정합성을 맞추는데 상당히 어려운 문제를 만들어 낸다.

### 5.1.2 주의사항

---

트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다.

## 5.2 MySQL 엔진의 잠금

---

MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.
MySQL 엔진 레벨 잠금은 모든 스토리지 엔진에 영향을 미친다. 하지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다.
MySQL 엔진에서는 테이블 락, 메타데이터 락, 네임드 락을 제공한다.

### 5.2.1 글로벌 락

---

글로벌 락(GLOBAL LOCK)은 FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있다.
MySQL에서 제공하는 잠금 가운데 가장 범위가 크다. 즉, MySQL 서버 전체이다. 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.

글로벌 락이 설정되어 있다면 다른 세션에서 SELECT를 제외한 대부분의 DDL, DML 문장은 락이 해제될 때까지 대기 상태로 남는다.

MySQL 8.0으로 넘어오면서 InnoDB가 기본 스토리지 엔진이 되었고 따라서 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없어졌다. 이에 따라서 좀 더 가벼운 글로벌 락의 필요성이 생겼다.

이러한 요구에 백업 락이 등장하였고 백업 락을 획득하면 모든 세션에서 다음과 같은 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 된다.
* 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
* REPAIR TABLE과 OPTIMIZE TABLE 명령
* 사용자 관리 및 비밀번호 변경

하지만 백업 락은 일반적인 테이블의 데이터 변경은 허용된다.

### 5.2.2 테이블 락

---

테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.

명시적으로는 LOCK TABLES table_name [ READ | WRITE ]명령어를 사용하며, UNLOCK TABLES 명령으로 반납할 수 있다.

묵시적인 테이블 락은 MyISAM, MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 다음, 즉시 잠금을 해제하는 형태이다.
InnoDB의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하므로 데이터 변경에 대한 묵시적인 테이블 락이 발생하지 않는다.

### 5.2.3 네임드 락

---

네임드 락은 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.이 잠금의 특징은 대상이 테이블이나 레코드와 같은 데이터베이스 객체가 아니라는 것이다.
네임드 락은 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.

### 5.2.4 메타데이터 락

---

메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다. 메타데이터 락은 명시적으로 획득할 수 없으며, 즉 자동으로 획득하는 잠금이다.

## 5.3 InnoDB 스토리지 엔진 잠금

---

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. 이러한 방식 덕분에 MyISAM 보다 뛰어난 동시성 처리를 제공한다.

### 5.3.1 InnoDB 스토리지 엔진의 잠금

---

InnoDB는 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지락, 테이블 락으로 레벨업되는 경우가 없다.

일반 DBMS와는 다르게 InnoDB는 레코드 락뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재한다.

### 5.3.1.1 레코드 락

---

InnoDB는 다른 DBMS와의 레코드 락과는 차이점이 존재한다. 일반적인 DBMS의 경우 레코드 락은 레코드 자체를 락하지만 InnoDB의 경우 인덱스나 자동 생성된 클러스터 인덱스를 이용해 잠근다.

InnoDB는 pk나 유니크 인덱스에 의한 변경 작업에서는 캡에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

### 5.3.1.2 갭 락

---

다른 DBMS와는 다르게 InnoDB는 레코드 락뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락이라는 것이 존재한다.

갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어하는 것이다.
갭 락은 그 자체보다는 넥스트 키 락의 일부로 사용된다.

### 5.3.1.3 넥스트 키 락

---

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다.
InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 목적이다.

그런데 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.

### 5.3.1.4 자동 증가 락

---

MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는 칼럼 속성을 제공한다. 이때 AUTO_INCREMENT 칼럼에 대해 동시 여러 INSERT가 진행되면 각 레코드는 중복되지 않은 값을 가져야한다.
이를 위해서 내부적으로 AUTO_INCREMENT 칼럼에 대해 잠금을 설정한다. 이를 AUTO_INCREMENT 락이라고 한다.

AUTO_INCREMENT 락은 레코드 락이나 넥스트 키 락과는 달리 INSERT와 같이 레코드가 추가 되는 경우에만 잠깐 락이 걸렸다가 해제된다.
따라서 AUTO_INCREMENT 락을 명시적으로 획득하고 해제하는 방법은 없다.

### 5.3.2 인덱스와 잠금

---

InnoDB의 잠금와 인덱스는 상당히 중요한 관계가 있다.

InnoDB의 잠금은 레코드를 잠그는것이 아닌 인덱스를 잠그는 방식으로 처리된다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.
하지만 InnoDB의 이런방식은 동시에 많은 레코드에 락을 거는 경우 발생할 수 있다. 이런 경우 쿼리에 대해 적절한 인덱스가 준비돼 있지 않을 때 발생하므로 InnoDB에서 인덱스 설계를 잘해야한다.

### 5.3.3 레코드 수준의 잠금 확인 및 해제

---

InnoDB이 사용하는 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡하다.
테이블 수준의 잠금의 대상이 테이블이므로 문제가 발생할 때 쉽게 발견되고 해결할 수 있다.
하지만 레코드 수준의 잠금에서는 테이블의 레코드 각각에 잠금이 걸리므로 해당 레코드가 자주 사용되지 않으면 문제가 오랜시간 방치 될 가능성이 있다.

## 5.4 MySQL의 격리 수준

---

트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지 결정하는 것이다.
격리 수준은 다음과 같이 크게 4가지 나뉜다. 또한 아래로 내려갈수록 격리 정도가 높아지며, 동시성은 떨어지지만 데이터의 정합성은 높아진다.

| 격리 수준            | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
|------------------|------------|---------------------|--------------|
| READ UNCOMMITTED | O          | O                   | O            |
| READ COMMITTED   | X          | O                   | O            |
| REPEATABLE READ  | X          | X                   | O            |
| SERIALIZABLE     | X          | X                   | X            |

### 5.4.1 READ UNCOMMITTED

---

트랜잭션에서 처리한 데이터를 COMMIT하지 않은 상태에서 다른 트랜잭션이 해당 데이터를 조회할 수 있게 허용하는 격리 수준이다.
이런 상태에서 아직 COMMIT하지 않은 데이터를 볼 수 있는 것을 DIRTY READ라고 한다. 따라서 이 격리 수준에서는 데이터 정합성에 문제가 발생할 수 있다.

### 5.4.2 READ COMMITTED

---

트랜잭션에서 처리한 데이터를 COMMIT한 후에만 다른 트랜잭션이 해당 데이터를 조회할 수 있게 허용하는 격리 수준이다.
이 격리 수준에서는 DIRTY READ가 발생하지 않는다. 하지만 NON-REPEATABLE READ가 발생할 수 있다.
NON_REPEATABLE 문제로 인해 한 트랜잭션에서 같은 SELECT 쿼리문에 대한 답이 다르게 나올 수 있으므로 이또한 정합성에 문제가 발생할 수 있다.

### 5.4.3 REPEATABLE READ

---

REPEATBALE READ는 InnoDB에서 기본적으로 사용하는 격리 수준이다.
REPEATBALE READ는 한 트랜잭션에서 항상 같은 값을 반환받는 것을 보장하는 격리 수준이다.
즉, 한 트랜잭션에서 같은 SELECT 쿼리문을 두 번 이상 실행하면 그 사이에 다른 트랜잭션이 값을 변경하더라도 처음에 읽은 데이터를 동일하게 반환한다.
이를 통해 NON-REPEATABLE READ 문제를 해결할 수 있다. 하지만 PHANTOM READ 문제는 여전히 발생할 수 있다.
PHANTOM READ는 한 트랜잭션에서 같은 SELECT 쿼리문을 두 번 이상 실행하면 그 사이에 다른 트랜잭션이 레코드를 추가하거나 삭제하면서 처음에 읽은 데이터와 다른 데이터를 읽게 되는 현상이다.
또한 트랜잭션이 종료되지 않는다면 언두 영역에 데이터가 무한정 늘어날 수 있으므로 주의해야한다.

### 5.4.4 SERIALIZABLE

---

SERIALIZABLE은 가장 엄격한 격리 수준이다. SERIALIZABLE은 트랜잭션을 순차적으로 실행하는 것과 같은 효과를 내므로 PHANTOM READ 문제도 발생하지 않는다.
따라서 동시 처리 성능도 다른 격리 수준보다 떨어진다. 하지만 데이터 정합성은 가장 높다.
