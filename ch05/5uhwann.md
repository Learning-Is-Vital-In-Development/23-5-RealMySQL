# ch5: 트랜잭션과 잠금

**트랜잭션**: 논리적인 작업 셋을 모두 완벽히 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해 작업의 일부만 적용되는 현상이 발생하지 않게 만들어 작업의 완정성을 보장해 주는 기능

**잠금(Lock)**: 잠금은 여러 커넥션에서 동시에 동일한 자원(레코드, 테이블)을 요청할 경우 한 시점에는 하나의 커넥션만 해당 자원을 변경할 수 있게 해주는 역할을 한다. 데이터 정합성을 위한 트랜잭션과는 달리 동시성 제어를 위한 기능이다.

## 트랜잭션

### MySQL에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업 셋에 몇개의 쿼리가 있든 그 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않는 것을 보장해 준다.

- MyISAM 스토리지 엔진은 적용X

  → partial update를 발생시키며, 이것은 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만듬


MySQL의 트랜잭션은 애플리케이션 개발에서 고민해야 할 문제를 줄여주는 아주 필수적인 DBMS의 기능이다.

→실패한 쿼리로 인해 발생한 남은 레코드를 다시 처리하는 작업을 제거해줌

### 주의사항

프로그램 코드에서 트랜잭션의 범위를 최소화해야 한다.

- 데이터베이스 커넥션 수는 제한적이기 때문에 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 좋지 않다.
- 네트워크를 통해 원격 서버와 통신하는 등 외부와의 통신 작업은 트랜잭션 내에서 제거해야 한다. → DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태에 빠짐

## MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨, MySQL 엔진 레벨로 나뉜다.

MySQL 엔진은 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분으로 MySQL 엔진 레벨 잠금은 모든 스토리지 엔진에 영향을 미치지지만, 스토리지 엔진 레벨의 잠근은 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 글로벌 락

글로벌 락은 MySQL에서 제공하는 잠금 가운데 가장 큰 범위다.

한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 DDL, DML 문장 실행이 글로벌 락 해제까지 대기 상태로 존재한다.

트랜잭션을 지원하는 InnoDB 스토리지 엔진이 MySQL의 기본 스토리지 엔진이 되면서부터 데이터 정합성을 위해 모든 데이터 변경 작업을 멈출필요가 사라졌다.

→ 조금 더 가벼운 글로벌 락의 필요성이 생김.

→ MySQL8.0 버전부터 백업 락 도입.

특정 세션에서 백업 락을 획득 시, 모든 세션은 다음과 같은 정보를 변경할 수 없다.

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

**하지만 일반적인 테이블의 데이터 변경은 허용된다.**

### 테이블 락

테이블 락은 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 테이블 락을 획득할 수 있다.

**명시적 획득 방법**

- `LOCK TABLES table_name [ READ | WRITE]`
- `UNLOCK TABLES` 명령으로 잠금 반납 가능
- 온라인 작업에 상당한 영향을 미치기 때문에 특별한 상황이 아니라면 애플리케이션에서 사용할 필요가 거의 없음

**묵시적 테이블 락**

InnoDB 테이블은 스토리지 엔진 차원의 레코드 기반 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인한 묵시적 테이블 락이 설정되지는 않다. → DDL 쿼리의 경우에만 테이블 락 설정

### 네임드 락

네임드 락은 `GET_LOCK()` 함수를 이용해 임의 문자열에 대해 잠금을 설정 가능.

이 락은 테이블, 레코드와 같은 데이터베이스 객체가 아니라 단순 사용자가 지정한 문자열에 대해 획등하고 반납하는 잠금이다.

많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용 가능하다.

→ 배치 프로그램처럼 한번에 많은 레코드를 변경하는

### 메타데이터 락

메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금이다.

메타데이터 락은 명시적으로 획득하거나 해제하는 것이 아닌 테이블의 이름을 변경하는 경우에 획득하는 잠금이다.

## InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반 잠금 방식을 탑재하고 있다.

### InnoDB 스토리지 엔진의 잠금

- **레코드 락**

    레코드 자체만을 잠그는 것을 레코드 락이라고 한다.

    InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다.

    레코드 자체를 자체를 잠그느냐, 아니면 인덱스를 잠그느냐는 큰 차이를 만들어 낸다.

- **갭 락**

    갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것이다.

    갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 INSERT 되는 것을 제어하는 것이다.

- **넥스트 키 락**

    레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다.

- **자동 증가 락**

    AUTO_INCREMENT 락은 INSERT와 REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요하다.

    AUTO_INCREMENT 락은 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸리고 즉시 해제된다.

    자동 증가 값이 한 번 증가하면 절대 줄어들지 않는 이유가 AUTO_INCREMENT 잠금을 최소화하기 위해서다.

### 인덱스와 잠금

InnoDB 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식이기 때문에 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

이러한 방식 때문에, 만약 인덱스 설계가 제대로 되어 있지 않다면 테이블의 많은 레코드를 스캔하고 잠그게 된다. 따라서 MySQL의 InnoDB에서 인덱스 설계가 매우 중요하다.

## MySQL의 격리 수준

트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하느 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

**격리수준**

- `READ UNCOMMITTED`
- `READ COMMITTED`
- `REPEATABLE READ`
- `SERIALIZABLE`

위에서부터 차례로 트랜잭션 간의 데이터 격리 정도가 높아지며, 동시 처리 성능은 떨어진다.

`READ UNCOMMITTED`과 `READ COMMITTED`는 일반적인 데이터베이스에서는 거의 사용X

`SERIALIZABLE`  또한 동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다.

### Read UNCOMMITTED

`READ UNCOMMITTED` 격리 수준에선 각 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.

이 경우, 더티 리드(Dirty read)가 발생할 수 있다.

더티 리드는 애플리케이션 개발자와 사용자를 상당히 혼란스럽게 만들기 때문에 이를 허용하는 `READ UNCOMMITTED` 격리 수준은 사용하지 않아야 한다.

<aside>
💡 더티 리드(Dirty read)란 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 말한다.

</aside>

### READ COMMITTED

오라클 DBMS에서 기본으로 사용되는 격리 수준이며 더티 리드가 현상은 발생하지 않는다. COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회가 가능하기 때문이다.

`READ COMMITTED` 격리수준에서는 “NON-REPEATABLE READ”라는 부정합 문제가 발생할 수 있다.

<aside>
💡  NON-REPEATABLE READ는 하나의 트랜잭션 내에서 SELECT 쿼리를 실행 했을 때는 항상 같은 결과를 가져와야 한다는 “REPEATABLE READ” 정합성에 어긋나는 것을 말한다.

</aside>

### REPEATABLE READ

`REPEATABLE READ` 는 MySQL InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준이다.

`REPEATABLE READ` 에서는 트랜잭션이 ROLLBACK 될 가능성을 대비해 변경되기 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경하는 방식은 MVCC 방식을 사용하기 때문에 “NON-REPEATABLE READ”라는 부정합이 발생하지 않는다.

### SERIALIZABLE

가장 단순한 격리 수준이면서 가장 엄격한 격리 수준이다.

동시 처리 성능은 다른 트랜잭션 격리 수준보다 떨어진다.

InnoDB 스토리지 엔진의 갭 락과 넥스트 키 락 사용 덕에 “PHANTOM READ” 문제가 해결되어 MySQL 에서는 굳이 `SERIALIZABLE`을 사용할 필요는 없다

<aside>
💡 “PHANTOM READ”란 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 말한다.

</aside>
