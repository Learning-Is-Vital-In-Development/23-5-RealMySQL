# 5.트랜잭션과 잠금

## 트랜잭션은 작업의 완전성을 보장해 주는 것이다.

# 5.1 트랜잭션

## 5.1.1 MySQL에서의 트랜잭션

- 트랜잭션은 하나의 논리적인 작업 셋 안에 쿼리의 개수는 중요하지 않다. 중요한 것은 작업 셋이 적용되거나 적용 안되게 보장해주는 것이다.
- 진행하다 오류가 나서 중단이 되면, 진행하던 시점에서 멈추는게 아니라 실행을 안했던 상태로 꺼져야하는것이다.

## 5.1.2 주의사항

1. 프로그램 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다는 것
2. 네트워크 작업이 있는 경우엔 반드시 트랜잭션에서 배제해야 한다.

# 5.2 MySQL 엔진의 잠금

잠금은 크게 두가지로 나눌 수 있다. MySQL 엔진 레벨과 스토리지 엔진 레벨이 있다.

## 5.2.1 글로벌 락

- 글로벌 락은 FLUSH TABLES WITH READ LOCK 명령으로 획득할 수 있고, 범위가 가장 크다.
- 특정 세션에서 획득하면 SELET를 제외한 DDL 문장이나 DML 문장을 실행하지 못하고 대기 상태로 남아짐.
- MySQL 8.0 부터는 백업 툴들의 안정적인 실행을 위해 백업 락이 도입됨.

## 5.2.2 테이블 락

- 개별 테이블 단위로 설정되는 잠금.
- 명시적, 묵시적으로 특정 테이블의 락을 획득할 수 있다.
- Inno DB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기에 DML로 인해 묵시적인 테이블 락이 설정되지는 않는다.  DDL의 경우에는 영향을 미친다.

## 5.2.3 네임드 락

- 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.
- 이 잠금은 데이터베이스 객체가 아닌 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.
- 배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 된다. 이 때 네임드락을 이용해 쿼리를 실행하면 데드락을 아주 쉽게 해결할 수 있다.

## 5.2.4 메타데이터 락

- 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.
- 이 잠금은 명시적으로 획득, 해제하는 것이 아닌 특정 경우에서 자동으로 획득하는 잠금이다.
- 테이블의 이름을 변경할 때, 하나의 쿼리로 실행하는 것이 좋다.
- 2개의 쿼리로 나눠서 실행하면 “Table not found” 오류를 발생시킬 수 있기 때문.

# 5.3 InnoDB 스토리지 엔진 잠금

- MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 **레코드 기반의 잠금 방식을 탑재 이런 이유에서 MyISAM보다 훨 뛰어난 동시성 처리 제공**

## 5.3.1 InnoDB 스토리지 엔진의 잠금

- 레코드 기반의 잠금 기능을 제공해, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 락 에스컬레이션이 없다.

### 5.3.1.1 레코드 락

- 레코드 자체만 잠그는 것을 의미.
- Inno DB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠그는 특징을 가지고 있음.
- 레코드 자체를 잠그느냐, 인덱스를 잠그느냐는 상당히 크고 중요한 차이를 만들어 낸다.

### 5.3.1.2 갭 락

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미.
- 그 사이 간격에 새로운 레코드가 생성되는 것을 제어

### 5.3.1.3 넥스트 키 락

- 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 의미.
- REPEATABLE READ 격리 수준을 사용해야 한다.
- innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화되면, 변경을 위해 검색하는 레코드에는 잠금이 걸린다.
- 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생. 그래서 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 캡 락을 줄이는 것이 좋음.

### 5.3.1.4 자동 증가 락

- AUTO_INCREMENT가 사용된 테이블에 동시에 여러 레코드가 insert되는 경우, 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가지도록 해주는 테이블 수준의 잠금이다.
- INSERT나 REPLACE 쿼리와 같이 새로운 레코드를 저장하는 쿼리에만 사용된다.
- 자동 증가 락은 하나만 존재하기 때문에 동시에 INSERT가 일어나는 경우 하나의 쿼리는 해당 잠금을 기다려야 한다.
- 자동 증가 락은 명시적으로 명시적으로 해제하거나 획득할 수 없다.

## 5.3.2 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식으로 처리.
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야한다.

## 5.3.3 레코드 수준의 잠금 확인 및 해제

- InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡하다. 문제의 원인이 잘 발견되지도 않는다.

# 5.4 MySQL의 격리 수준

- 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.
- 격리 수준은 크게 “READ UNCOMMITTED”, “READ COMMITTED”, “REPEATABLE”, “SERIALIZABLE” 이렇게 4가지로 나뉜다.
- 4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지고, 동시 처리 성능이 떨어질거라 예상하는데, SERIALIZATION 격리 수준이 아니면 크게 성능의 개선이나 저하는 발생 X

## 5.4.1 READ UNCOMMITTED

- READ-UNCOMMITTED 격리 수준에서는 트랜잭션의 변경 내용이 Commit이나 Rollback 여부에 관계없이 다른 트랜잭션에서 보인다.

### 문제점

- 작업이 완료되지 않았음에도 다른 트랙잭션에서 볼 수 있다는 특징 때문에 데이터 정합성에 많은 문제 발생.
- 즉, 더티 리드가 발생.

## 5.4.2 READ COMMITTED

- 완료된 데이터만 다른 트랜잭션에서 볼 수 있기에 더티 리드 같은 현상은 발생하지 않는다.

### 문제점

- READ-COMMITTED 격리 수준에서도 NON-REPEATABLE READ라는 부정합의 문제가 존재한다. 레코드가 반복되어 읽어지는 상황에서 발생하는 데이터 부정합 문제이다.
- NON-REPEATABLE READ는 일반적인 웹 서비스에서는 큰 문제가 되지 않을 수 있지만, 금전적인 처리와 연결되었을 때 큰 문제점이 될 수 도 있다.

## 5.4.3 REPEATABLE READ

- NON-REPEATABLE READ가 발생하지 않음.
- 트랜잭션 내부에서 실행되는 SELECT와 외부에서 실행되는 SELECT의 차이가 없는 READ-COMMITTED 격리 수준과는 다르게 REPEATABLE-READ 격리 수준은 기본적으로 SELECT 쿼리 문장도 트랜잭션 범위 내에서만 작동한다.

### 문제점

- REPEATABLE-READ 격리 수준에서도 PHANTOM READ라는 부정합 현상이 발생할 수 있다.
- 일반적인 상황에서는 갭 락과 넥스트 키 락 덕분에 PHANTOM READ이 발생하지 않는다.

## 5.4.4 SERIALIZABLE

- 가장 단순하면서 엄격한 격리 수준임.
- 처리 성능도 다른 트랜잭션 격리 수준보다 떨어짐.
- 이 격리 수준에서는 PHANTOM READ가 발생하지 않는데, 굳이 사용할 필요성은 없어보인다.