# 4장 MySQL 아키텍쳐

## 4.1 MySQL 엔진 아키텍쳐

다른 DBMS에 비해 독특한 구조. 다른 DBMS에서는 가질 수 없는 장점이 있지만, 다른 DBMS에서는 문제되지 않을 것들이 문제가 되기도 한다.

### 4.1.1 MySQL의 전체 구조

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분

### 4.1.2 MySQL 스레딩 구조

MySQL서버는 프로세스 기반이 아니라 스레드 기반. 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.

포그라운드 스레드

MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리문장을 처리한다.
사용자가 커넥션을 종료하면 스레드는 다시 스레드 캐시로 되돌아간다.(이미 대기중인 스레드가 있다면 종료)

백그라운드 스레드

InnoDB에서 다음과 같은 작업이 백그라운드로 처리된다.

- Insert 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

이 중 ‘로그 스레드’와 ‘쓰기 쓰레드’가 중요하다. 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 디스크를 최적으로 사용할 수 있는 만큼 충분히 설정하는 것이 좋다.   

### 4.1.3 MySQL 메모리 할당 및 사용 구조

MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.

글로벌 메모리 영역

- 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당(필요에 따라 2개 이상 가능)
- 모든 스레드에 의해 공유
- 대표적으로 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼가 있다.

로컬 메모리 영역

- 클라이언트 스레드가 쿼리를 처리할때 사용하는 메모리 영역
- 클라이언트 스레드 별로 독립적으로 할당, 공유되어 사용되지 않는다.
- 각 쿼리의 용도별로 필요할 때만 공간 할당
- 계속 할당되는 공간(커넥션 버퍼나 결과 버퍼)과 쿼리를 실행하는 순간에만 할당(소트버퍼나 조인버퍼)로 나뉨
- 대표적으로 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼가 존재

### 4.1.4 플러그인 스토리지 엔진 모델

수많은 사용자의 요구조건을 만족시키기 위해 기본적으로 제공되는 스토리지 엔진 외에 부가적인 기능을 더 제공하는 스토리지 엔진을 개발하여 플러그인 형태로 제공할 수 있다.

MySQL 서버에서는 스토리지 엔진 뿐만 아니라 다양한 기능을 플러그인 형태로 지원  

### 4.1.5 컴포넌트

플러그인 아키텍쳐를 대체하기 위해 지원
플러그인끼리 통신 불가, 캡슐화 불가, 초기화의 어려움의 단점을 보완하기 위해 구현

### 4.1.6 쿼리 실행 구조

사용자가 SQL 요청을 하면 MySQL엔진에서 쿼리파서, 전처리기, 옵티마이저, 쿼리 실행기를 통해 SQL 결과를 반환

4.1.6.1 쿼리 파서

- MySQL이 인식할 수 있는 최소 단위의 어휘인 토큰으로 분해해 트리 형태의 구조로 만드는 작업. 쿼리의 기본 문법 오류 발생

4.1.6.2 전처리기

- 트리 기반의 쿼리 문장에 구조적인 문제점 확인, 객체의 존재 유무나 객체의 접근 권한을 확인 하는 과정 수행

4.1.6.3 옵티마이저

- 쿼리 문장을 가장 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할

4.1.6.4 실행엔진

- 핸들러(스토리지 엔진)에 요청 및 결과값을 입력값으로 연결하는 역할 수행

4.1.6.5 핸들러

- 스토리지 엔진을 의미한다. InnoDB 테이블을 조작하는 경우 핸들러는 InnoDB 스토리지 엔진

### 4.1.7 복제

MySQL 서버에서 중추적인 역할

### 4.1.8 쿼리 캐시

과거 빠른 응답을 필요로 할때 사용되었으나, 동시 처리 성능 저하와 버그의 원인이 되며 MySQL 8.0에서는 해당 기능이 제거되었다.

### 4.1.9 스레드 풀

내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많아도 CPU가 제한된 개수의 스레드 처리만 집중할 수 있게하여 서버 자원 소모를 줄이는 것이 목적.

CPU의 프로세서 친화도를 높이고 불필요한 컨텍스트 스위치를 줄여 오버헤드를 낮출 수 있다는 장점.

일반적으로 스레드 그룹 개수는 CPU 코어의 개수와 맞추는 것이 좋다.

엔터프라이즈 에디션만 제공, Percona 서버의 스레드 풀은 플러그인 형태로 작동하게 구현.

### 4.2.10 트랜잭션 지원 메타데이터

MySQL 5.7버전까지는 테이블 구조를 파일 기반으로 관리

하지만 파일기반 메타데이터는 생성 및 변경 작업에 트랜잭션을 지원하지 않아, 비정상 종료에 대해 일관성이 보장되지 않아 테이블이 깨지는 현상 발생

MySQL 8.0부터는 테이블 구조 정보나 스토어드 프로그램의 코드 관련 정보등의 정보를 모두 InnoDB의 테이블에 저장되도록 변경

## 4.2 InnoDB 스토리지 엔진 아키텍쳐

InnoDB는 MySQL 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금 제공, 따라서 높은 동시성 처리 가능

### 4.2.1 프라이머리 키에 의한 클러스터링

프라이머리 키 값의 순서대로 디스크에 저장, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용

프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 빨리 처리 될 수 있다.

### 4.2.2 외래 키 지원

InnoDB 스토리지 엔진 레벨에서만 지원하는 기능  
서비스용 데이터베이스에서는 생성하지 않는 경우도 있지만, 개발환경의 데이터베이스에서는 좋은 가이드 역할

foreign_key_checks 시스템 변수를 사용해여 외래키 관계에 대한 체크 작업을 중단함으로서 긴급 조치 가능.(이때 CASCADE 옵션도 무시). 데이터의 일관성을 맞춰준 후 활성해야하한다.  

### 4.2.3 MVCC

잠금을 사용하지 않는 일관된 읽기를 제공하는 데에 목적. InnoDB는 언두로그를 이용해 이 기능을 구현

Read Commited 이상의 경우의 조회할 경우 언두 영역의 데이터를 반환

잠금을 사용하지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업 가능

### 4.2.4 잠금 없는 일관된 읽기

InnoDB 스토리지 엔진은 MVCC을 이용해 잠금을 걸지 않고 읽기 작업 수행.

SERIALIZABLE이 아닌 다른 격리 수준에서는 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽는 작업이 가능하다.

### 4.2.5 자동 데드락 감지

InnoDB 스토리지 엔진은 잠금 대기 목록을 그래프 형태로 관리한다.

데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 데드락 상태에 빠진 트랜잭션을 강제 종료한다.(이때 언두 로그의 양이 적은 트랜잭션이 먼저 종료된다.)

잠금 목록을 체크할때 잠금 목록에 새로운 잠금이 걸리므로 동시 처리 스레드가 매우 많은 경우 CPU 자원 소모가 생길 수 있다. 이는 성능에 악영향을 미친다.

innodb_deadlock_detect 시스템 변수를 OFF하고 innodb_lock_wait_timeout 시스템 변수를 활성화하며 데드락 상황에서 일정 시간 동안 잠금을 획득하지 못했을 경우
요청이 실패하고 에러 메시지를 반환하게 만드는 방식으로 문제를 우회할 수 있다.

### 4.2.6 자동화된 장애 복구

InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행하는데, 디스크나 서버 하드웨어 이슈로 자동 복구를 못하는 경우 MySQL 서버가 종료되어 버린다.

이때는 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 시작해야한다. 1~6의 값을 가지며 단계 별로 선별적 자동복구를 진행 할 수 있다.

### 4.2.7 InnoDB 버퍼 풀

디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간. 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할(변경된 데이터를 모아 한번에 처리)도 같이 한다.

버퍼 풀의 구조
- 페이지 크기(innodb_page_size 시스템 변수에 설정된)의 조각으로 쪼개어 스토리지 엔진이 데이터를 필요로 할때마다 해당 데이터 페이지를 읽어서 각 조각에 저장.
- LRU 리스트, 플러시 리스트, 프리 리스트 3개의 자료구조를 관리
- LRU 리스트 : 디스크로 부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화
- 플러시 리스트 : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(이하 더티페이지)의 변경 시점 기준의 페이지를 관리.
- 프리 리스트 : 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어있는 페이지들의 목록, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 익어와야 하는 경우 사용

버퍼 풀과 리두 로그
- InnoDB의 버퍼 풀은 서버의 메모리가 허용한 만큼 크게 설정하면 쿼리의 성능이 빨라진다. 이는 데이터 캐시 기능만 향상되는것이다.
- 데이터베이스의 성능 향상을 위해서는 데이터 캐시 기능 말고도 쓰기 버퍼링이 있는데, 버퍼 풀은 리두 로그를 사용해 쓰기 버퍼링을 향상 시킨다.
- InnoDB 버퍼 풀의 크기를 고려해 리두 로그 파일의 크기를 조절하며 최적값을 선택하는 것이 좋다.

버퍼 풀 상태 백업 및 복구
- 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비돼 있으므로, 디스크에서 데이터를 읽어오지 않아도 되기 때문에 쿼리 처리 성능이 증가한다.
- 따라서 서버를 셧다운 했다가 다시 시작하는 경우 테이블과 인덱스에 대해 풀스캔을 실행하는 경우도 있었다.
- MySQL 5.6버전 부터는 innodb_buffer_pool_dump_now 시스템 변수를 이용해 현재 InnoDB 버퍼 풀의 상태를 백업하고, innodb_buffer_pool_load_now 시스템 변수를 이용해 백업된 버퍼 풀의 상태를 복구할 수 있다..

### 4.2.8 Double Write Buffer

리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만을 기록한다. 
하드웨의 오작동이나 시스템의 비정상 종료 등으로 더티 페이지를 디스크 파일로 플러시 할때 페이지가 일부만 기록되는 파셜 페이지 현상이 나타나면, 해당 페이지의 내용을 복구할 수 없을 수도 있다.  

순서는 다음과 같다.
1. InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 더티페이지를 모아 DoubleWrite 버퍼에 한번에 기록한다.
2. 만약 운영체제가 중간에 비정상적으로 종료가 된다면 재시작할때 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지를 비교한다.
3. 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다.

innodb_doublewrite 시스템 변수로 DoubleWrite 기능의 사용 여부를 제어할 수 있다. 
리두로그를 동기화 하지 않았으면 DoubleWrite도 비활성화 하는 것이 좋다.

### 4.2.9 언두 로그

InnoDB는 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업. 이렇게 백업된 데이터를 언두로그라고 한다.

언두로그는 데이터의 복구를 통해 트랜잭션을 보장하고, 격리 수준에 맞게 변경 중인 레코드가 아닌 언두로그에 백업해둔 데이터를 조회함으로서 격리 수준을 보장한다.

- 언두로그 모니터링

MySQL 5.5 이전 버전에는 한번 증가한 언두 로그 공간이 다시 줄어들지 않아, 대용량의 데이터를 처리하는 트랜잭션이나 오랜시간 실행되는 트랜잭션일 경우 언두로그의 양이 급격히 증가할 수 있었다. 디스크 사용량의 증가 뿐만 아니라, 필요한 레코드를 찾는 과정에서 쿼리의 성능이 저하되는 문제가 있다. 

MySQL 8.0에서는 언두로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄일 수 있고, MySQL 서버에서 자동으로 줄여주기도 함으로서 문제점을 해결. 그럼에도 불구하고 언두로그에 대한 모니터링이 필요하다.  

- 언두 테이블스페이스 관리  

언두 테이블스페이스 ⇒ 언두로그가 저장되는 공간  
하지만 확장의 한계로 인해 MySQL 8.0에서는 언두로그는 항상 시스템 테이블 스페이스 외부의 별도 로그 파일에 기록되도록 개선됐다.

### 4.2.10 체인지 버퍼  

변경해야할 인덱스 페이지가 버퍼 풀에 있지 않고 디스크로부터 읽어와서 업데이트 해야한다면, 이를 임시 공간에 저장해두고 바로 결과를 반환하는데, 이 때 사용하는 임시 메모리 공간이 체인지 버퍼.  

### 4.2.11 리드 로그 및 로그 버퍼

리두 로그

MySQL 서버가 비정상적으로 종료했을 때 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구하게 해준다. 쓰기 비용이 낮은 자료구조로 구현되어 있다.
데이터 베이스 서버는 성능도 중요하기 때문에 데이터 파일 뿐만 아니라 리두로그를 버퍼링할 수 있는 버퍼 풀이나 리두로그를 버퍼링 할 수 있는 로그 버퍼와 같은 자료구조도 가지고 있다.

MySQL 서버가 비정상적으로 종료되는 경우는 데이터 파일은 다음과 같다.

1. 커밋됐지만 데이터 파일에 기록되지 않은 데이터

2. 롤백됐지만 데이터 파일에 이미 기록된 데이터

1번의 경우 리두로그에 저장된 데이터를 데이터파일에 다시 복사하는 방식, 2번의 경우 변경되기 전 데이터를 가진 언두 로그의 내용을 데이터 파일에 복사하는 방식으로 해결하는데 이때 변경 상태를 확인하기 위해 리두로그가 필요하다.

InnoDB 스토리지 엔진의 리두 로그는 MySQL 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화 되어있다.
MySQL 8.0 부터는 비활성화를 통해 데이터의 적재 시간을 단축 시킬 수 있으나, 서비스 도중에는 리두 로그를 활성화 해야한다.

### 4.2.12 어댑티브 해시 인덱스

사용자가 수동으로 생성하는 인덱스가 아닌, 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스

수많은 스레드가 실행 될 경우 B-Tree 인덱스에서 검색시간이 증가하는데, 이를 해결하기 위해 InnoDB는 자주 읽히는 데이터 페이지의 키값을 이용해 해시 인덱스를 생성한다.

해시 인덱스는 ‘인덱스 키 값(B-Tree 인덱스 id + B-Tree 인덱스의 실제 키 값)’과 ‘데이터 페이지의 메모리 주소 주소’의 쌍으로 관리한다.

어댑티브 해시 인덱스를 사용함으로서 성능상의 이점을 가져갈 수 있지만, 다음과 같은 경우에는 성능향상에 큰 도움이 되지 않는다.

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(Join, LIke 패턴)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

특히 테이블이 삭제되거나 변경될 때에는 오히려 성능이 감소하기 때문에 어댑티브 해시 인덱스의 효율을 통해 사용 여부를 판단하는 것이 중요하다.

### 4.2.13 InnoDB vs MyISAM, MEMORY

MySQL 8.0부터 MySQL 서버의 모든 기능을 InnoDB 스토리지 엔진만으로 구현할 수 있게 되었다. MyISAM과 MEMORY 스토리지 엔진이 가질 수 있는 장점이 없다.

## 4.3 MyISAM 스토리지 엔진 아키텍쳐

### 4.3.1 키 캐시

디스크로부터의 I/O를 해결해 줄만한 어떠한 캐시나 버퍼링 기능도 가지고 있지 않음

InnoDB의 버퍼 풀과 비슷한 역할

인덱스만을 대상, 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할

### 4.3.2 운영체제의 캐시 및 버퍼

InnoDB처럼 전문적으로 캐시나 버퍼링을 하지는 못한다.

운영체제의 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙, 운영체제가 사용할 수 있는 캐시 공간을 위해 충분한 메모리가 있어야함.

### 4.3.3 데이터 파일과 프라이머리 키 구조

InnoDB와 다르게 프라이머리 키에 대한 클러스터링 없이 데이터 파일이 힙 공간처럼 활용

Insert 되는 순서대로 데이터 파일에 저장

## 4.4 MySQL 로그 파일

### 4.4.1 에러 로그 파일

MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일.

MySQL 설정 파일(my.cnf)에서 log_error라는 이름의 파라미터로 정의된 경로에 생성

별도로 정의되지 않은 datadir 파라미터에 설정된 디렉토리에 .err라는 확장자가 붙은 파일로 생성

자주 접하는 로그 메시지들은 다음과 같다.

- MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
- 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
- 쿼리 처리 도중 발생하는 문제에 대한 에러 메시지
- 비정상적으로 종료된 커넥션 메시지
- InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지
- MySQL의 종료 메시지

### 4.4.2 제너럴 쿼리 로그 파일

서버에서 실행되는 쿼리의 전체 목록을 확인 가능.

쿼리 로그 파일에는 시간단위로 실행됐던 쿼리의 내용이 모두 기록된다.

쿼리 실행 중에 에러가 발생해도 로그 파일에 기록하는 특징이 있다.

### 4.4.3 슬로우 쿼리 로그

서비스 운영 중 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝에서, 문제의 쿼리를 판별하기 위해 사용

long_query_time 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리 모두 기록

반드시 쿼리가 정상적으로 실행이 완료되야 기록
