# 4장 MySQL 아키텍쳐

## 4.1 MySQL 엔진 아키텍쳐

다른 DBMS에 비해 독특한 구조. 다른 DBMS에서는 가질 수 없는 장점이 있지만, 다른 DBMS에서는 문제되지 않을 것들이 문제가 되기도 한다.

### 4.1.1 MySQL의 전체 구조

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분

### 4.1.2 MySQL 스레딩 구조

MySQL서버는 프로세스 기반이 아니라 스레드 기반. 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.

포그라운드 스레드는 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리문장을 처리한다.

사용자가 커넥션을 종료하면 스레드는 다시 스레드 캐시로 되돌아간다.(이미 대기중인 스레드가 있다면 종료)

백그라운드 스레드

InnoDB에서 다음과 같은 작업이 백그라운드로 처리된다.

- Insert 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

이 중 ‘로그 스레드’와 ‘쓰기 쓰레드’가 중요하다. 데이터를 읽는 작업은 많은 스레드를 필요로 하지 않지만 쓰기 작업은 충분한 스레드가 필요하다.

### 4.1.3 MySQL 메모리 할당 및 사용 구조

MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.

글로벌 메모리 영역

- 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당(필요에 따라 2개 이상 가능)
- 모든 스레드에 의해 공유
- 대표적으로 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼가 있다.

로컬 메모리 영역

- 클라이언트 스레드가 쿼리를 처리할때 사용하는 메모리 영역
- 클라이언트 스레드 별로 독립적으로 할당, 공유되어 사용되지 않는다.
- 각 쿼리의 용도별로 필요할 때만 공간 할당
- 계속 할당되는 공간(커넥션 버퍼나 결과 버퍼)과 쿼리를 실행하는 순간에만 할당(소트버퍼나 조인버퍼)로 나뉨
- 대표적으로 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼가 존재

### 4.1.4 플러그인 스토리지 엔진 모델

### 4.1.5 컴포넌트

플러그인 아키텍쳐를 대체하기 위해 지원

플러그인끼리 통신 불가, 캡슐화 불가, 초기화의 어려움의 단점을 보완하기 위해 구현

### 4.1.6 쿼리 실행 구조

사용자가 SQL 요청을 하면 MySQL엔진에서 쿼리파서, 전처리기, 옵티마이저, 쿼리 실행기를 통해 SQL 결과를 반환

4.1.6.1 쿼리 파서

MySQL이 인식할 수 있는 최소 단위의 어휘인 토큰으로 분해해 트리 형태의 구조로 만드는 작업. 쿼리의 기본 문법 오류 발생

4.1.6.2 전처리기

트리 기반의 쿼리 문장에 구조적인 문제점 확인, 객체의 존재 유무나 객체의 접근 권한을 확인 하는 과정 수행

4.1.6.3 옵티마이저

쿼리 문장을 가장 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할

4.1.6.4 실행엔진

핸들러(스토리지 엔진)에 요청 및 결과값을 입력값으로 연결하는 역할 수행

4.1.6.5 핸들러

스토리지 엔진을 의미한다. InnoDB 테이블을 조작하는 경우 핸들러는 InnoDB 스토리지 엔진

### 4.1.7 복제

MySQL 서버에서 중추적인 역할

### 4.1.8 쿼리 캐시

과거 빠른 응답을 필요로 할때 사용되었으나, 동시 처리 성능 저하와 버그의 원인이 되며 MySQL 8.0에서는 해당 기능이 제거되었다.

### 4.1.9 스레드 풀

엔터프라이즈 에디션만 제공, Percona 서버의 스레드 풀은 플러그인 형태로 작동하게 구현.

## 4.2 InnoDB 스토리지 엔진 아키텍쳐

InnoDB는 MySQL 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금 제공, 따라서 높은 동시성 처리 가능

### 4.2.1 프라이머리 키에 의한 클러스터링

프라이머리 키 값의 순서대로 디스크에 저장, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용

프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 빨리 처리 될 수 있다.

### 4.2.2 외래 키 지원

InnoDB 스토리지 엔진 레벨에서만 지원하는 기능

서비스용 데이터베이스에서는 생성하지 않는 경우도 있지만, 개발환경의 데이터베이스에서는 좋은 가이드 역할

foreign_key_checks 시스템 변수를 사용해여 외래키 관계에 대한 체크 작업을 중단함으로서 긴급 조치 가능.(이때 CASCADE 옵션도 무시). 데이터의 일관성을 맞춰준 후 활성해야하한다.

### 4.2.3 MVCC

잠금을 사용하지 않는 일관된 읽기를 제공하는 데에 목적. InnoDB는 언두로그를 이용해 이 기능을 구현

Read Commited 이상의 경우의 조회할 경우 언두 영역의 데이터를 반환

잠금을 사용하지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업 가능

### 4.2.4 잠금 없는 일관된 읽기

### 4.2.5 자동 데드락 감지

### 4.2.9 언두 로그

InnoDB는 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업. 이렇게 백업된 데이터를 언두로그라고 한다.

언두로그는 데이터의 복구를 통해 트랜잭션을 보장하고, 격리 수준에 맞게 변경 중인 레코드가 아닌 언두로그에 백업해둔 데이터를 조회함으로서 격리 수준을 보장한다.

- 언두로그 모니터링

MySQL 5.5 이전 버전에는 한번 증가한 언두 로그 공간이 다시 줄어들지 않아, 대용량의 데이터를 처리하는 트랜잭션이나 오랜시간 실행되는 트랜잭션일 경우 언두로그의 양이 급격히 증가할 수 있었다. 디스크 사용량의 증가 뿐만 아니라, 필요한 레코드를 찾는 과정에서 쿼리의 성능이 저하되는 문제가 있다.

MySQL 8.0에서는 언두로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄일 수 있고, MySQL 서버에서 자동으로 줄여주기도 함으로서 문제점을 해결. 그럼에도 불구하고 언두로그에 대한 모니터링이 필요하다.

- 언두 테이블스페이스 관리

언두 테이블 스페이스 ⇒ 언두로그가 저장되는 공간

### 4.2.10 체인지 버퍼

변경해야할 인덱스 페이지가 버퍼 풀에 있지 않고 디스크로부터 읽어와서 업데이트 해야한다면, 이를 임시 공간에 저장해두고 바로 결과를 반환하는데, 이 때 사용하는 임시 메모리 공간이 체인지 버퍼.

### 4.2.11 리드 로그 및 로그 버퍼

리두 로그

MySQL 서버가 비정상적으로 종료했을 때  데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구하게 해준다. 쓰기 비용이 낮은 자료구조로 구현되어 있다.

MySQL 서버가 비정상적으로 종료되는 경우는 데이터 파일은 다음과 같다.

1. 커밋됐지만 데이터 파일에 기록되지 않은 데이터

2. 롤백됐지만 데이터 파일에 이미 기록된 데이터

1번의 경우 리두로그에 저장된 데이터를 데이터파일에 다시 복사하는 방식, 2번의 경우 변경되기 전 데이터를 가진 언두 로그의 내용을 데이터 파일에 복사하는 방식으로 해결하는데 이때 변경 상태를 확인하기 위해 리두로그가 필요하다.

### 4.2.12 어댑티브 해시 인덱스

사용자가 수동으로 생성하는 인덱스가 아닌, 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스

수많은 스레드가 실행 될 경우 B-Tree 인덱스에서 검색시간이 증가하는데, 이를 해결하기 위해 InnoDB는 자주 읽히는 데이터 페이지의 키값을 이용해 해시 인덱스를 생성한다.

해시 인덱스는 ‘인덱스 키 값(B-Tree 인덱스 id + B-Tree 인덱스의 실제 키 값)’과 ‘데이터 페이지의 메모리 주소 주소’의 쌍으로 관리한다.

어댑티브 해시 인덱스를 사용함으로서 성능상의 이점을 가져갈 수 있지만, 다음과 같은 경우에는 성능향상에 큰 도움이 되지 않는다.

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(Join, LIke 패턴)
- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

특히 테이블이 삭제되거나 변경될 때에는 오히려 성능이 감소하기 때문에 어댑티브 해시 인덱스의 효율을 통해 사용 여부를 판단하는 것이 중요하다.

### 4.2.13 InnoDB vs MyISAM, MEMORY

MySQL 8.0부터 MySQL 서버의 모든 기능을 InnoDB 스토리지 엔진만으로 구현할 수 있게 되었다. MyISAM과 MEMORY 스토리지 엔진이 가질 수 있는 장점이 없다.

## 4.3 MyISAM 스토리지 엔진 아키텍쳐

### 4.3.1 키 캐시

디스크로부터의 I/O를 해결해 줄만한 어떠한 캐시나 버퍼링 기능도 가지고 있지 않음

InnoDB의 버퍼 풀과 비슷한 역할

인덱스만을 대상, 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할

### 4.3.2 운영체제의 캐시 및 버퍼

InnoDB처럼 전문적으로 캐시나 버퍼링을 하지는 못한다.

운영체제의 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙, 운영체제가 사용할 수 있는 캐시 공간을 위해 충분한 메모리가 있어야함.

### 4.3.3 데이터 파일과 프라이머리 키 구조

InnoDB와 다르게 프라이머리 키에 대한 클러스터링 없이 데이터 파일이 힙 공간처럼 활용

Insert 도니느 순서대로 데이터 파일에 저장

## 4.4 MySQL 로그 파일

### 4.4.1 에러 로그 파일

MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일.

MySQL 설정 파일(my.cnf)에서 log_error라는 이름의 파라미터로 정의된 경로에 생성

별도로 정의되지 않은 datadir 파라미터에 설정된 디렉토리에 .err라는 확장자가 붙은 파일로 생성

자주 접하는 로그 메시지들은 다음과 같다.

- MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
- 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
- 쿼리 처리 도중 발생하는 문제에 대한 에러 메시지
- 비정상적으로 종료된 커넥션 메시지
- InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지
- MySQL의 종료 메시지

### 4.4.2 제너럴 쿼리 로그 파일

서버에서 실행되는 쿼리의 전체 목록을 확인 가능.

쿼리 로그 파일에는 시간단위로 실행됐던 쿼리의 내용이 모두 기록된다.

쿼리 실행 중에 에러가 발생해도 로그 파일에 기록하는 특징이 있다.

### 4.4.3 슬로우 쿼리 로그

서비스 운영 중 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝에서, 문제의 쿼리를 판별하기 위해 사용

long_query_time 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리 모두 기록

반드시 쿼리가 정상적으로 실행이 완료되야 기록
